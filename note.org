#+title: Notes

* How to Setup C++ on Linux

** system setup
#+begin_src sh
  sudo apt update && sudo apt upgrade
  sudo apt install cmake g++
#+end_src


** project tree

#+begin_src plain
 ./
 ├── build.sh
 ├── CMakeLists.txt  
 ├── README.org
 └── src
     └── Main.cpp
#+end_src


** CMakeLists.txt
#+begin_src text
  cmake_minimum_required (VERSION 3.5)

  project (<Project name>)

  set (CMAKE_CXX_FLAG "${CMAKE_CXX_FLAGS} -Wall -Werror -std=c++14")
  set (source_dir "${PROJECT_SOURCE_DIR}/src/")

  file (GLOB source_files "${source_dir}/*.cpp")

  add_executable (<Project name> ${source_files})
#+end_src

** build.sh

#+begin_src sh
  #!/bin/sh

  cmake -G "Codelite - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug
#+end_src

* How C++ Works

~<<~ is actually a function.

~std::cin.get()~ is just waiting for a enter to stop.

* How the C++ Compiler Works

compile and link.

generate object file for each of out cpp file.

file have no meaning in C++, you can compile a .god file, as long as you tell the compiler that it is cpp file.

pre-processing
- include: read and paste, JUST paste !!!
- define: replace keyword.
- if and endif:
  #+begin_src cpp
    #if 0
    here is no function
    #endif

    #if 1
    // here keep still
    #endif
  #+end_src  

* How the C++ Linker Works

find where each function is, and link them together.

you have to have an entry point, which is default called main.

after compiling, you function will convert to a function with signature. Linking is to link the function with same signature.

** function declaration in multiple file

#+begin_src cpp
  // case 1

  // log.h
  #pragma once
  void Log(char* message) {
    std::cout << message << std::endl;
  }

  // log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  // main.cpp
  #include <iostream>
  #include "log.h"

  int Multiply(int a, int b) {
    Log("Multiply");
    return a*b;
  }

  int main () {
    std::cout << Multiply(6,4) << std::endl;
    std::cin.get();
  }
#+end_src

This code will go wrong while linking, because ~#include~ is actually paste its code there, leading to appear 2 same function in cpp file and linker don't know which function to link.

*** solution 1 static keyword

#+begin_src cpp
  // log.h
  #pragma once

  static void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

use ~static~ so that every file have its own version of Log function. 

*** solution 2 only declare in header

#+begin_src cpp
  // log.h
  #pragma once

  void Log(char* message);

  // Log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

* Variables in C++

int has 4 bytes, which is 32 bits.
maximum is \( 2 ^{31}-1 \), one bit for sign.

bool take one bit to represent.

#+begin_src cpp
  #include <iostream>
  using namespace std;

  int main() {
    cout << sizeof(bool) << endl;
  }

#+end_src

#+RESULTS:
: 1

* Function in C++

prevent code duplication. 


* C++ Header Files

instead of paste declaration, you can use header file.

~#pragma once~: only include the file once in one transaction unit.

#+begin_src cpp
  #pragma once

  // equal to

  #ifndef _LOG_H
  #define _LOG_H

  // ...
  #endif
#+end_src

why this need?
#+begin_src cpp
  // common.h
  include "Log.h"

  // Log.h
  // ...

  // main.cpp
  #include "Log.h"
  #include "common.h"

#+end_src

it will go wrong.

** separate C and C++
#+begin_src cpp
  #include <stdlib.h> // C

  #include <iostream>
#+end_src

* How to DEBUG C++ in VISUAL STUDIO

skip

* CONDITIONS and BRANCHES in C++

optimization will avoid if, it make programme slow

separate the condition and the function body even only one statement, because while debugging, you cannot figure which statement the program run. 

actually separate every statements.

#+begin_src cpp
  else if 

  // equal to 
  else {
    if (){}
  }

#+end_src

* BEST Visual Studio Setup for C++ 
skip

* Loops in C++ 

while and for. 

for loop for specific time and make an index.

do while. 

* Control Flow in C++ 

- continue: go to the next iteration
- break: end the loop
- return: end the function
  
  
  
* POINTERS in C++

pointer is just memory address. 

** null pointer
#+begin_src cpp 
  void* ptr = NULL;
  void* ptr = nullptr;
  void* ptr = 0;
#+end_src

** assignment
#+begin_src cpp
  int var = 8;
  void* ptr = &var;
#+end_src

** type help computer to control var 
#+begin_src cpp
  int var = 8;
  int* ptr = &var;
  *ptr = 10;
#+end_src

** REFERENCES in C++

ampersand

#+begin_src cpp
  int a = 6;
  int& ref  = a; // assignment immediately
#+end_src

it is just an alias which will be replace after compiling.

This is just a syntax sugar. 
#+begin_src cpp 
  void increase(int *value) {
    ,*value ++;
  }

  int main(){
    int a  =5;
    increase(&a);
  }

  // equal to
  void increase(int& value) {
    value++;
  }

  int main() {
    int a = 5 ;
    increase(a);
    // just like increase (int& value = a);
  }
#+end_src

* CLASSES in C++
** concept
create your data structure. just like Structure in C.

#+begin_src cpp
  class Player {
    int x, y;
    int speed;
  }

  int main() {
    Player player;
  }
#+end_src

** public
it can only be accessed by its own function without public.
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
  };
#+end_src


** function
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
  player.Move(1,-1);



  void Move(Player& player, int xa, int ya) {
    player.x += xa * player.speed;
    player.y += ya * player.speed;
  }
  Move(player, 1, -1);

#+end_src

* CLASSES vs STRUCTS in C++

class is private by default.
struct is public.

This is the only difference.

#+begin_src cpp
  struct Player {
  private:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
#+end_src

* How to Write a C++ Class
#+begin_src cpp
  #include <iostream>

  class Log {
  public:
    const int LogLevelError = 0;
    const int LogLevelWarnning = 1;
    const int LogLevelInfo = 2;
    
  private:
    int m_LogLevel = LogLevelInfo;
    
  public:
    void SetLevel(int level){
      m_LogLevel = level;
    }
    void Error(const char* message){
      if (m_LogLevel >= LogLevelError){
        std::cout << "[Error]" << message << std::endl;
      }
    }
    
    void Warn(const char* message){
      if (m_LogLevel >= LogLevelWarnning) {
        std::cout << "[Warning]" << message << std::endl;
      }
    }
    void Info(const char* message){
      if (m_LogLevel >= LogLevelInfo ){
        std::cout << "[Info]" << message << std::endl;
      }
    }
  };

  int main() {
    Log log;
    log.SetLevel(log.LogLevelWarnning) ;
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    
    return 0;
  }
#+end_src

#+RESULTS:
| [Warning]Hello! |
| [Error]Hello!   |

* Static in C++

- outside of class: internal
- inside: share memory with others. 

today only talk about outside. 
  
#+begin_src cpp
  static int a = 5;
#+end_src

every var outside the function is considered as a global var. 
add static make it only visible in that one file.

use static as much as you can.

* Static for class and struct

make var only one, or shared across the class or struct.

let's learn from examples.

** example 1

#+begin_src cpp 
  #include <iostream>

  struct Entity {
    int x, y;
    
    void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int main() {
    Entity e;
    e.x = 2;
    e.y = 3;
    
    Entity ee= {4,6};

    e.Print();
    ee.Print();
    
    return 0;
  }
#+end_src

#+RESULTS:
| 2 | 3 |
| 4 | 6 |

** example 2
make the var static, across all entities, there is only one x, y, in other word, they shared x and y.

#+begin_src cpp 
  #include <iostream>

  struct Entity {
    static int x, y;
    
    void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int Entity::x;
  int Entity::y;
  // static in struct can not be touch outside
  // so when you declare one Entity, x and y inside did not be declared.

  int main() {
    Entity e;
    e.x = 2;
    e.y = 3;
    
    Entity ee;
    ee.x = 4;
    ee.y = 5;
    
    e.Print();
    ee.Print();
    
    return 0;
  }
#+end_src

#+RESULTS:
| 4 | 5 |
| 4 | 5 |

** example 3

This code went wrong, because static method can not access non static var.



#+begin_src cpp
  #include <iostream>

  struct Entity {
    int x, y;
    
    static void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int Entity::x;
  int Entity::y;

  int main() {
    Entity::x = 2;
    Entity::y = 3;
    
    Entity::x = 4;
    Entity::y = 5;
    
    Entity::Print();
    Entity::Print();
    
    return 0;
  }
#+end_src

#+RESULTS:


That because method in class actually hidden the parameter.

#+begin_src cpp
  void Print(<Entity e>) {
    std::cout << <e.>x << " , " << <e.>y << std::endl;
  }
#+end_src

if you add the static, it is the same as you write the method outside the class, so the method use the var that are not exist. 

* ENUMS

** how to define
#+begin_src cpp
  #include <iostream>
  
  enum Example {
    A, B, C
    // default start from 0, step 1
  };
#+end_src

change attribute
#+begin_src cpp
  #include <iostream>

  enum Example : char{ // here it has to be integer
    A = 5, B, C
    // change the start. 
  };
#+end_src

** example in a class
how about inside a class.

#+begin_src cpp
  #include <stdio>

  class Log {
  public:
    enum Level {
      Error, Warning, Info
    }
    
    void Error(const char* message) {
      // ...
    }
    void SetLevel() {
      // ...
    }

  }
  int main() {
    Log log; // you just need to declare the class. 
    log.SetLevel(Log::Error); 
    // it will went wrong, because you have a Error enum and function.
  }
#+end_src

** best practice
#+begin_src cpp 
  enum Level {
    LevelError, LevelWarning, LevelInfo
  }
#+end_src


* Constructors

Constructor is a kind of initialize function.

when you use ~e.Print()~, it will request parameter already to be initialized rather than output a random value.

#+begin_src cpp
  class Log {
  public:
    int x;
    Log(){}; // it will set all value to be 0 default. 
  };
#+end_src

you can also initialize by a more convenient way.
#+begin_src cpp
  class Log {
  public:
    int x;
    Log (int X) {
      x = X;
    }
  }

  int main() {
    Log l(1);
  }
#+end_src

if you want only one class instance.

#+begin_src cpp
  class Log {
  private:
    Log() {}
  public:
    int x;
    static void Write() {
      //...
    }
  }

  int main() {
    Log l; // this is invalid.
  }
#+end_src


* Destructor

 
#+begin_src cpp
  #include <iostream>
  using namespace std;

  class Log {
  public:
    Log(){
      cout << "create class" << endl;
    };
    int x;
    ~Log(){
      cout << "destroy class" << endl;
    }
  };

  void Print() {
    Log l;
    l.~Log();
    cout << "print over" << endl;
  }
  
  int main() {
    Print();
    return 0;
  }
#+end_src

#+RESULTS:
| create  | class |
| destroy | class |
| print   | over  |
| destroy | class |

* Inheritance

it allow us to create child class, and avoid duplication. 

#+begin_src cpp 
  class Entity {
  public:
    int x, y;
    Entity () {};
    
    void Move(int xa, int ya) {
      x += xa;
      y += ya;
    } 
  };


  class Player : public Entity {
  public:
    char* name;
    
    void PrintName() {
      
    }
  }

  int main() {
    Player player;
    player.Move(1,1);
  }
#+end_src

* Virtual Function

This help to reduce duplication.

** fail to reduce
#+begin_src cpp
  #include <iostream>

  class Entity {
  public:
    std::string GetName() { return "Entity"; }
  };

  class Animal : public Entity {
  public:
    std::string sound;
    Animal (std::string sounda) {
      sound = sounda;
    }
    std::string GetName() { return sound; }
  };

  void MakeSound(Entity* entity) {
    std::cout << entity->GetName() << std::endl;
  }

  int main() {
    Entity* e = new Entity();
    MakeSound(e);
    
    Animal* a = new Animal("Dog");
    MakeSound(a);
 }
#+end_src

#+RESULTS:
| Entity |
| Entity |

but if we use virtual function, everything is different.

** best practice
#+begin_src cpp
  #include <iostream>

  class Entity {
  public:
    virtual std::string GetName() { return "Entity"; }
  };

  class Animal : public Entity {
  public:
    std::string sound;
    Animal (std::string sounda) {
      sound = sounda;
    }
    std::string GetName() override { return sound; }
  };

  void MakeSound(Entity* entity) {
    std::cout << entity->GetName() << std::endl;
  }

  int main() {
    Entity* e = new Entity();
    MakeSound(e);
     
    Animal* a = new Animal("Dog");
    MakeSound(a);
#+end_src

#+RESULTS:
| Entity |
| Dog    |

** conclusion

cpp in object-oriented language and class is the import way to realize that.
when you are writing a class, you must assume that there is an function every child-classes has, but every class is a slightly different. It is kind of like a var in class. 


* Interfaces (pure virtual functions)

It is a kind of virtual function. 

| feature   | virtual | pure |
|-----------+---------+------|
| implement | must    | no   |
| override  | y/n     | must |

#+begin_src cpp
  #include <iostream>

  class Printable 
  {
  public:
    virtual std::string GetClassName () = 0;
  };

  class Dog : public Printable
  {
  public:
    std::string GetClassName() override {
      return "Dog";
    }
  };

  void Print (Printable* obj)
  {
    std::cout << obj->GetClassName() << std::endl;
  }

  int main()
  {
    Dog* dog = new Dog();
    Print(dog);
  }
#+end_src

#+RESULTS:
: Dog

** conclusion

virtual function is the behavior that can be generalized.
pure virtual function is not. 
