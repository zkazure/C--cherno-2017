#+title: Notes

* How to Setup C++ on Linux

** system setup
#+begin_src sh
  sudo apt update && sudo apt upgrade
  sudo apt install cmake g++
#+end_src


** project tree

#+begin_src plain
 ./
 ├── build.sh
 ├── CMakeLists.txt  
 ├── README.org
 └── src
     └── Main.cpp
#+end_src


** CMakeLists.txt
#+begin_src text
  cmake_minimum_required (VERSION 3.5)

  project (<Project name>)

  set (CMAKE_CXX_FLAG "${CMAKE_CXX_FLAGS} -Wall -Werror -std=c++14")
  set (source_dir "${PROJECT_SOURCE_DIR}/src/")

  file (GLOB source_files "${source_dir}/*.cpp")

  add_executable (<Project name> ${source_files})
#+end_src

** build.sh

#+begin_src sh
  #!/bin/sh

  cmake -G "Codelite - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug
#+end_src

* How C++ Works

~<<~ is actually a function.

~std::cin.get()~ is just waiting for a enter to stop.

* How the C++ Compiler Works

compile and link.

generate object file for each of out cpp file.

file have no meaning in C++, you can compile a .god file, as long as you tell the compiler that it is cpp file.

pre-processing
- include: read and paste, JUST paste !!!
- define: replace keyword.
- if and endif:
  #+begin_src cpp
    #if 0
    here is no function
    #endif

    #if 1
    // here keep still
    #endif
  #+end_src  

* How the C++ Linker Works

find where each function is, and link them together.

you have to have an entry point, which is default called main.

after compiling, you function will convert to a function with signature. Linking is to link the function with same signature.

** function declaration in multiple file

#+begin_src cpp
  // case 1

  // log.h
  #pragma once
  void Log(char* message) {
    std::cout << message << std::endl;
  }

  // log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  // main.cpp
  #include <iostream>
  #include "log.h"

  int Multiply(int a, int b) {
    Log("Multiply");
    return a*b;
  }

  int main () {
    std::cout << Multiply(6,4) << std::endl;
    std::cin.get();
  }
#+end_src

This code will go wrong while linking, because ~#include~ is actually paste its code there, leading to appear 2 same function in cpp file and linker don't know which function to link.

*** solution 1 static keyword

#+begin_src cpp
  // log.h
  #pragma once

  static void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

use ~static~ so that every file have its own version of Log function. 

*** solution 2 only declare in header

#+begin_src cpp
  // log.h
  #pragma once

  void Log(char* message);

  // Log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

* Variables in C++

int has 4 bytes, which is 32 bits.
maximum is \( 2 ^{31}-1 \), one bit for sign.

bool take one bit to represent.

#+begin_src cpp
  #include <iostream>
  using namespace std;

  int main() {
    cout << sizeof(bool) << endl;
  }

#+end_src

#+RESULTS:
: 1

* Function in C++

prevent code duplication. 


* C++ Header Files

instead of paste declaration, you can use header file.

~#pragma once~: only include the file once in one transaction unit.

#+begin_src cpp
  #pragma once

  // equal to

  #ifndef _LOG_H
  #define _LOG_H

  // ...
  #endif
#+end_src

why this need?
#+begin_src cpp
  // common.h
  include "Log.h"

  // Log.h
  // ...

  // main.cpp
  #include "Log.h"
  #include "common.h"

#+end_src

it will go wrong.

** separate C and C++
#+begin_src cpp
  #include <stdlib.h> // C

  #include <iostream>
#+end_src

* How to DEBUG C++ in VISUAL STUDIO

skip

* CONDITIONS and BRANCHES in C++

optimization will avoid if, it make programme slow

separate the condition and the function body even only one statement, because while debugging, you cannot figure which statement the program run. 

actually separate every statements.

#+begin_src cpp
  else if 

  // equal to 
  else {
    if (){}
  }

#+end_src

* BEST Visual Studio Setup for C++ 
skip

* Loops in C++ 

while and for. 

for loop for specific time and make an index.

do while. 

* Control Flow in C++ 

- continue: go to the next iteration
- break: end the loop
- return: end the function
  
  
  
* POINTERS in C++

pointer is just memory address. 

** null pointer
#+begin_src cpp 
  void* ptr = NULL;
  void* ptr = nullptr;
  void* ptr = 0;
#+end_src

** assignment
#+begin_src cpp
  int var = 8;
  void* ptr = &var;
#+end_src

** type help computer to control var 
#+begin_src cpp
  int var = 8;
  int* ptr = &var;
  *ptr = 10;
#+end_src

** REFERENCES in C++

ampersand

#+begin_src cpp
  int a = 6;
  int& ref  = a; // assignment immediately
#+end_src

it is just an alias which will be replace after compiling.

This is just a syntax sugar. 
#+begin_src cpp 
  void increase(int *value) {
    ,*value ++;
  }

  int main(){
    int a  =5;
    increase(&a);
  }

  // equal to
  void increase(int& value) {
    value++;
  }

  int main() {
    int a = 5 ;
    increase(a);
    // just like increase (int& value = a);
  }
#+end_src

* CLASSES in C++
** concept
create your data structure. just like Structure in C.

#+begin_src cpp
  class Player {
    int x, y;
    int speed;
  }

  int main() {
    Player player;
  }
#+end_src

** public
it can only be accessed by its own function without public.
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
  };
#+end_src


** function
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
  player.Move(1,-1);



  void Move(Player& player, int xa, int ya) {
    player.x += xa * player.speed;
    player.y += ya * player.speed;
  }
  Move(player, 1, -1);

#+end_src

* CLASSES vs STRUCTS in C++

class is private by default.
struct is public.

This is the only difference.

#+begin_src cpp
  struct Player {
  private:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
#+end_src

* How to Write a C++ Class
#+begin_src cpp
  #include <iostream>

  class Log {
  public:
    const int LogLevelError = 0;
    const int LogLevelWarnning = 1;
    const int LogLevelInfo = 2;
    
  private:
    int m_LogLevel = LogLevelInfo;
    
  public:
    void SetLevel(int level){
      m_LogLevel = level;
    }
    void Error(const char* message){
      if (m_LogLevel >= LogLevelError){
        std::cout << "[Error]" << message << std::endl;
      }
    }
    
    void Warn(const char* message){
      if (m_LogLevel >= LogLevelWarnning) {
        std::cout << "[Warning]" << message << std::endl;
      }
    }
    void Info(const char* message){
      if (m_LogLevel >= LogLevelInfo ){
        std::cout << "[Info]" << message << std::endl;
      }
    }
  };

  int main() {
    Log log;
    log.SetLevel(log.LogLevelWarnning) ;
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    
    return 0;
  }
#+end_src

#+RESULTS:
| [Warning]Hello! |
| [Error]Hello!   |

* Static in C++

- outside of class: internal
- inside: share memory with others. 

today only talk about outside. 
  
#+begin_src cpp
  static int a = 5;
#+end_src

every var outside the function is considered as a global var. 
add static make it only visible in that one file.

use static as much as you can.

* Static for class and struct

make var only one, or shared across the class or struct.

let's learn from examples.

** example 1

#+begin_src cpp 
  #include <iostream>

  struct Entity {
    int x, y;
    
    void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int main() {
    Entity e;
    e.x = 2;
    e.y = 3;
    
    Entity ee= {4,6};

    e.Print();
    ee.Print();
    
    return 0;
  }
#+end_src

#+RESULTS:
| 2 | 3 |
| 4 | 6 |

** example 2
make the var static, across all entities, there is only one x, y, in other word, they shared x and y.

#+begin_src cpp 
  #include <iostream>

  struct Entity {
    static int x, y;
    
    void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int Entity::x;
  int Entity::y;
  // static in struct can not be touch outside
  // so when you declare one Entity, x and y inside did not be declared.

  int main() {
    Entity e;
    e.x = 2;
    e.y = 3;
    
    Entity ee;
    ee.x = 4;
    ee.y = 5;
    
    e.Print();
    ee.Print();
    
    return 0;
  }
#+end_src

#+RESULTS:
| 4 | 5 |
| 4 | 5 |

** example 3

This code went wrong, because static method can not access non static var.



#+begin_src cpp
  #include <iostream>

  struct Entity {
    int x, y;
    
    static void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int Entity::x;
  int Entity::y;

  int main() {
    Entity::x = 2;
    Entity::y = 3;
    
    Entity::x = 4;
    Entity::y = 5;
    
    Entity::Print();
    Entity::Print();
    
    return 0;
  }
#+end_src

#+RESULTS:


That because method in class actually hidden the parameter.

#+begin_src cpp
  void Print(<Entity e>) {
    std::cout << <e.>x << " , " << <e.>y << std::endl;
  }
#+end_src

if you add the static, it is the same as you write the method outside the class, so the method use the var that are not exist. 

* ENUMS

** how to define
#+begin_src cpp
  #include <iostream>
  
  enum Example {
    A, B, C
    // default start from 0, step 1
  };
#+end_src

change attribute
#+begin_src cpp
  #include <iostream>

  enum Example : char{ // here it has to be integer
    A = 5, B, C
    // change the start. 
  };
#+end_src

** example in a class
how about inside a class.

#+begin_src cpp
  #include <stdio>

  class Log {
  public:
    enum Level {
      Error, Warning, Info
    }
    
    void Error(const char* message) {
      // ...
    }
    void SetLevel() {
      // ...
    }

  }
  int main() {
    Log log; // you just need to declare the class. 
    log.SetLevel(Log::Error); 
    // it will went wrong, because you have a Error enum and function.
  }
#+end_src

** best practice
#+begin_src cpp 
  enum Level {
    LevelError, LevelWarning, LevelInfo
  }
#+end_src


* Constructors

Constructor is a kind of initialize function.

when you use ~e.Print()~, it will request parameter already to be initialized rather than output a random value.

#+begin_src cpp
  class Log {
  public:
    int x;
    Log(){}; // it will set all value to be 0 default. 
  };
#+end_src

you can also initialize by a more convenient way.
#+begin_src cpp
  class Log {
  public:
    int x;
    Log (int X) {
      x = X;
    }
  }

  int main() {
    Log l(1);
  }
#+end_src

if you want only one class instance.

#+begin_src cpp
  class Log {
  private:
    Log() {}
  public:
    int x;
    static void Write() {
      //...
    }
  }

  int main() {
    Log l; // this is invalid.
  }
#+end_src


* Destructor

 
#+begin_src cpp
  #include <iostream>
  using namespace std;

  class Log {
  public:
    Log(){
      cout << "create class" << endl;
    };
    int x;
    ~Log(){
      cout << "destroy class" << endl;
    }
  };

  void Print() {
    Log l;
    l.~Log();
    cout << "print over" << endl;
  }
  
  int main() {
    Print();
    return 0;
  }
#+end_src

#+RESULTS:
| create  | class |
| destroy | class |
| print   | over  |
| destroy | class |

* Inheritance

it allow us to create child class, and avoid duplication. 

#+begin_src cpp 
  class Entity {
  public:
    int x, y;
    Entity () {};
    
    void Move(int xa, int ya) {
      x += xa;
      y += ya;
    } 
  };


  class Player : public Entity {
  public:
    char* name;
    
    void PrintName() {
      
    }
  }

  int main() {
    Player player;
    player.Move(1,1);
  }
#+end_src

* Virtual Function

This help to reduce duplication.

** fail to reduce
#+begin_src cpp
  #include <iostream>

  class Entity {
  public:
    std::string GetName() { return "Entity"; }
  };

  class Animal : public Entity {
  public:
    std::string sound;
    Animal (std::string sounda) {
      sound = sounda;
    }
    std::string GetName() { return sound; }
  };

  void MakeSound(Entity* entity) {
    std::cout << entity->GetName() << std::endl;
  }

  int main() {
    Entity* e = new Entity();
    MakeSound(e);
    
    Animal* a = new Animal("Dog");
    MakeSound(a);
 }
#+end_src

#+RESULTS:
| Entity |
| Entity |

but if we use virtual function, everything is different.

** best practice
#+begin_src cpp
  #include <iostream>

  class Entity {
  public:
    virtual std::string GetName() { return "Entity"; }
  };

  class Animal : public Entity {
  public:
    std::string sound;
    Animal (std::string sounda) {
      sound = sounda;
    }
    std::string GetName() override { return sound; }
  };

  void MakeSound(Entity* entity) {
    std::cout << entity->GetName() << std::endl;
  }

  int main() {
    Entity* e = new Entity();
    MakeSound(e);
     
    Animal* a = new Animal("Dog");
    MakeSound(a);
#+end_src

#+RESULTS:
| Entity |
| Dog    |

** conclusion

cpp in object-oriented language and class is the import way to realize that.
when you are writing a class, you must assume that there is an function every child-classes has, but every class is a slightly different. It is kind of like a var in class. 


* Interfaces (pure virtual functions)

It is a kind of virtual function. 

| feature   | virtual | pure |
|-----------+---------+------|
| implement | must    | no   |
| override  | y/n     | must |

#+begin_src cpp
  #include <iostream>

  class Printable 
  {
  public:
    virtual std::string GetClassName () = 0;
  };

  class Dog : public Printable
  {
  public:
    std::string GetClassName() override {
      return "Dog";
    }
  };

  void Print (Printable* obj)
  {
    std::cout << obj->GetClassName() << std::endl;
  }

  int main()
  {
    Dog* dog = new Dog();
    Print(dog);
  }
#+end_src

#+RESULTS:
: Dog

** conclusion

virtual function is the behavior that can be generalized.
pure virtual function is not. 

* Visibility

no effect on program performance, just help to organize the code.

- protected: in that scope, only sub-class object can access.
- private
- public
 
* Arrays

** define
#+begin_src cpp
  int example[5];
  exampe[i];

  // equal to 
  int* ptr = example;
  *(ptr+2);
    
#+end_src

index of array in bracket will always start at the beginning, and then do an addition.

** new keyword 

content in the heap just address, so it is bad for performance
#+begin_src cpp
  int example[5]; // this is created by stack

  int* another = new int[5];
  // this is created by heap
  // and will not destory untill you use
  delete[] another;
#+end_src

** size of array

#+begin_src cpp
  int count = sizeof(another) / sizeof(int) // just go wrong
#+end_src

** no var for assign in array
#+begin_src cpp
  int size = 5;
  int example[size];              // go wrong

  static const in exampleSize = 5;
  int example[exampleSize];       // work
#+end_src

** grammar sugar
raw arrays is faster.
standard array is safer.

use standard array can avoid maintain another size var.
counts just can got by size().
#+begin_src cpp
  std::array<int, 5> another;
  another.size();                 // work
#+end_src

* How Strings Work

** basic concept
string is an array of character. 

It ends with 00 in memory.

string and char pointer.

what the difference with
#+begin_src cpp
  #include <iostream>

  int main ()
  {
    char* name1 = "chero";
    char name2[6] = {'c', 'h', 'e', 'r', 'o', '\0'};

    char name3[5] = {'c', 'h', 'e', 'r', 'o'};
    char name4[6] = {'c', 'h', 'e', 'r', 'o', 0};
    
    std::cout << name1 <<std::endl;
    std::cout << name2 <<std::endl;
    std::cout << name3 <<std::endl; // remind the third line
    // it will continue until find the 0 or '\0'
    std::cout << name4 <<std::endl;
    
    return 0;
  }
#+end_src

#+RESULTS:
| chero      |
| chero      |
| cherochero |
| chero      |

** std::string

#+begin_src cpp
  std::string name = "chero";      // it is actually a char array. 

  // iostream have the string
  // but you have to use string to output it 
  #include <string>
  std::cout << naem << std::endl;
#+end_src


** connect string 
#+begin_src cpp
  std::strng name = "const" + "string";
  // this will go wrong 
  // because "const" is a const char 

  std::string name = "const";
  name += "string";
#+end_src

** string in function
in the function, the parameter is actually passing the value by copying. Due to the string copy is quite slow, you should avoid to passing the string.

use reference instead:
#+begin_src cpp
  void print(const std::string& str) 
  {
    std::cout << str << std::endl;
  }
#+end_src

* string literals
** basic
This is the string literals. 
#+begin_src cpp
  "cherno";
#+end_src

** you can't do
#+begin_src cpp
  char* name = "chero";
  // this is undefined behaviour.
  name[2]  = "2"; // you do not know what will happen

  // the correct way
  char name[] = "chero";
  const char* naem = "chero";
#+end_src


** namespace of string literal

#+begin_src cpp
  using namespace tsd::string_literals;
  std::string name0 = "cherno"s + " hello";
#+end_src

** defferent
#+begin_src cpp
  char name[] = "cherno";
  name[2] = 'a';
#+end_src
This going to work. why?
the compiler actually copy the first string into to another variable, then modify it.

* CONST

** * and &
what is * and & really mean in the cpp
Both * and & have two different context.

|            | *                    | &                  |
|------------+----------------------+--------------------|
| operator   | get value of address | get address of var |
| declarator | pointer var          | reference var      |
| value      | actually value       | variable name      |

#+begin_src cpp
  int *a = 4; // create a pointer var with type int 
  int &a = b; // create a reference var with type int
#+end_src

in other way, int is the data type, but * and & is the variable type.

they are more close to variable.
#+begin_src cpp
  int *a, b; // a with pointer int type, b with int type
  int *a, *b; // both pointer int type. 
#+end_src

but in other way, they are more close to type
#+begin_src cpp
  const int a  = 1;
  int *b = 2;

  b = &a;  // wrong
  b = (int*) &a;
#+end_src

the most important is that, know the * and & are operator and type declarator.

** go into const

use Uppercase name to indicate the const property. 

read left-to-right: const apply to the first one meet it.

#+begin_src cpp
  const int* a = new int;
  // const meet int: int value cannot be modify
  int const* a = new int;
  // the same as above

  int* const a = new int;
  // * meet const: point value cannot be modify

  const int* const a = new int;
  // apply the knowledge you learn.
#+end_src

** function const

the function promise:
- not to modify the value of member variable
- not to called non-const function, because other function are allowed to modify the member variable
#+begin_src cpp
  class Entity
  {
    private:
    int m_X, m_Y;
    public:
    int Get() const
    {
      return m_X;
    }
  }
#+end_src

** mutable
mutable variable change be change in the const function.
or const function can change the mutable variable. 
#+begin_src cpp
  class Entity
  {
  private:
    mutable int a = 0;
  public:
    void add() const 
    {
      a++;
      std::cout << a << std::endl;
    }
  }
#+end_src

* the mutable keyword

two way to use

- lambda
- const
  

** what is the lambda
It is a kind of function

#+begin_src cpp
  auto <function> = [<captured>] (<parameter>) {
    // ...
  }
#+end_src

you can use the variable outside the function directly.
*However*, you can not change the captured var in the function

come from
#+begin_src cpp
  void f (int a) {
    // ...
  }
#+end_src

you do not need to define the var and able to use it directly.
** mutable with lambda

it allow you to "change" the captured var in the lambda,
but actually you can not change the really value, it is a kind of copy behavior.
#+begin_src cpp
  int a = 5;
  auto f = [a] () mutable
  {
    a++;
  }
  f();
  std::cout << a << std::endl;    // still be 5
#+end_src


come from
#+begin_src cpp
  auto f = [a] () {
    int b = a;
    b++;
    // ...
  }
#+end_src

* Member initializer lists

it just a way to initialize the var in lists.

** do not change the sequence

Even if the sequence is no effect
#+begin_src cpp
  class Entity 
  {
    private:
    int a;
    int b;
    public:
    Entity ()
    : b(0), a(0) {
      // it will still be initialized in the declared sequence
    }
  }
#+end_src

But the wrong sequence may make you think it is reasonable to make a assignment depend on b. 
But it will be wrong, because a initialize first. 

** a functional difference

#+begin_src cpp
  class Entity
  {
    private: 
    std::string m_Name;
    int x,y,z;
    public:
    Entity() 
    : x(0), y(0), z(0)
    {
      m_Name = "Unknown";
    }
  }
#+end_src

Here the m_Name will initilize twice.

#+begin_src cpp
  #include <iostream>

  class Example
  {
    public:
    Example ()
    {
      std::cout << "Created Entity!" << std::endl;
    }
    
    Example(int x)
    {
      std::cout << "created Entity with " << x << std::endl;
    }
  };

  class Entity
  {
    private: 
    std::string m_Name;
    Example m_Example;
    public:
    Entity()
    {
      m_Name = "Unknown";
      m_Example = Example(8);
    }
  };

  int main() {
    Entity e0;
    
    return 0;
  }

#+end_src

#+RESULTS:
| Created | Entity! |      |   |
| created | Entity  | with | 8 |

** correct one
#+begin_src cpp
  #include <iostream>

  class Example
  {
    public:
    Example ()
    {
      std::cout << "Created Entity!" << std::endl;
    }
    
    Example(int x)
    {
      std::cout << "created Entity with " << x << std::endl;
    }
  };

  class Entity
  {
    private: 
    std::string m_Name;
    Example m_Example;
    public:
    Entity()
    : m_Example(Example(8))
    {
      m_Name = "Unknown";
    }
  };

  int main() {
    Entity e0;
    
    return 0;
  }

#+end_src

#+RESULTS:
: created Entity with 8


* Ternary Operators
syntax sugar for conditional assignment

#+begin_src cpp
  int a = b>5 ? 10 : 5;
#+end_src


* How to Create/Instantiate objects

stack and heap

new and delete

* The NEW Keyword

allocate memory in heap.

create int in heap
1. tell system need 4 bytes memory
2. find 4 bytes continuous

it it a bit slow.

#+begin_src cpp
  Entity* e = new Entity();

  // similar to
  Entity *e  = (Entity*) malloc(sizeof(Entity));
#+end_src

* Implicit Conversion and the Explicit Keyword

** Implicit Conversion

The code functions properly due to C++'s implicit conversion feature. When C++ identifies a compatible data type, it automatically performs the implicit conversion process.

#+begin_src cpp
  class Entity
  {
    private:
    std::string m_Name;
    int m_Age;
    public:
    Entity(const std::string& name)
    : m_Name(name), m_Age(-1) {}

    Entity(int age)
    : m_Name("Unknown"), m_Age(age) {}
  };

  int main() {
    Entity a = "Cherno";
    Entity b = 22;
  }
#+end_src

But it can only perform only on implicit conversion process per times.

#+begin_src cpp
  void PrintEntity(const Entity& entity) {
    //...
  }

  int main() {
    PrintEntity(22);
    PrintEntity("Cherno");        // go wrong
  }
#+end_src

For the first code, the number 22 needs direct conversion to an Entity object.

However, in the second code, "cherno" exists as a character array, requiring a two-step conversion process: char array -> string -> entity. 

** explicit
It prevents automatic implicit type conversions from occurring.

#+begin_src cpp
  class Entity
  {
    private:
    std::string m_Name;
    int m_Age;
    public:
    Entity(const std::string& name)
    : m_Name(name), m_Age(-1) {}

    explicit Entity(int age)
    : m_Name("Unknown"), m_Age(age) {}
  };

  int main() {
    Entity a = "Cherno";
    Entity b = 22;                // go wrong
    Entity b = (Entity) 22;
    Entity b(22);
  }
#+end_src

* Operators and operator Overloading

operator overloading allow you to customize the behavior of operator in cpp. 

** objects operate
Sometime you want to use the normal operator to manipulate new data structure, but the behavior is undefined.

#+begin_src cpp
  struct Vector2
  {
    float x, y;
    
    Vector2 (float x, float y)
    : x(x), y(y) {}
    
    Vector2 Add (const Vector2& other) const 
    {
      return Vector2(x+other.x, y+other.y);
    }
    
    Vector2 Multiply (const Vector2 other) const
    {
      return Vector2(x*other.y, y*other.y);
    }

  };

  int main() {
    Vector2 position(4.0f, 4.0f);
    Vector2 speed(1.0f, 1.0f);
    Vector2 powerup(1.1f, 1.1f);
    
    Vector2 result = position.Add(speed.Multiply(powerup));
  }
#+end_src

** operator overloading
These code work but too messy, we can do in a more tricky way in cpp--operator overloading.

#+begin_src cpp
  struct Vector2
  {
    float x, y;
    
    Vector2 (float x, float y)
    : x(x), y(y) {}


    Vector2 Add (const Vector2& other) const 
    {
      return Vector2(x+other.x, y+other.y);
    }
    Vector2 operator+ (const Vector2& other) const
    {
      return Add(other);
    }  
    
    Vector2 Multiply (const Vector2& other) const
    {
      return Vector2(x*other.y, y*other.y);
    }
    Vector2 operator* (const Vector2& other) const
    {
      return Mutiply(other);
    }

  };

  int main() {
    Vector2 position(4.0f, 4.0f);
    Vector2 speed(1.0f, 1.0f);
    Vector2 powerup(1.1f, 1.1f);
    
    // Vector2 result = position.Add(speed.Multiply(powerup)); 
    Vector2 result = position + speed * powerup;
  }
#+end_src

** practice: overloading  <<
#+begin_src cpp
  struct Entity
  {
    float x, y;

    Entity (float x, float y)
    : x(x), y(y) {}
  };

  std::ostream& operator<< (std::ostream& stream, const Entity& other) const
  {
    stream << other.x << " , " << other.y;
    return stream;
  }

  int main()
  {
    Entity e(1.0f, 1.0f);

    cout << e << endl;
  }
#+end_src

** practice overloading ==
#+begin_src cpp
  struct Vector2
  {
    float x, y;

    Vector2 (float x, float y)
    : x(x), y(y) {}

    Vector2 operator== (const Vector2& other) const
    {
      return x==other.x && y==other.y;
    }

  };
#+end_src

* The "this" keyword

this is a pointer that refers to the current object instance within a member function.

#+begin_src cpp
  class Entity
  {
  public:
    int x, y;
    Entity(int x, int y)
    {
      // x=x; the variable in this function is priorty
      this->x = y;
      this->y = y;
    }
  }
#+end_src

* Object Lifetime

stack based variable live in the scope.
heap based variable live until be deleted.

** wrong example
This example is entirely incorrect.
The data that the pointer references will be destroyed beyond the scope.

#+begin_src cpp
  int* CreateArray()
  {
    int* array[50];
    return array;
  }

  // what you should do
  int* ModifyArray(int* array) 
  {
    // do something
    return array;
  }
#+end_src

** auto delete the heap

#+begin_src cpp
  class Entity
  {
    
  };

  class ScopedPtr
  {
  private:
    Entity* m_ptr;
  public:
    ScopedPtr(Entity* ptr)
    : m_ptr(ptr) {}
    
    ~ScopedPtr()
    {
      delete m_ptr;
    }
  }

  int main()
  {
    {
      ScopedPtr e = new Entity();
      // Entity* e = new Entity();  this will not be deleted beyond the scope.
    }
  }
#+end_src
