#+title: Notes

* How to Setup C++ on Linux

** system setup
#+begin_src sh
  sudo apt update && sudo apt upgrade
  sudo apt install cmake g++
#+end_src


** project tree

#+begin_src plain
 ./
 ├── build.sh
 ├── CMakeLists.txt  
 ├── README.org
 └── src
     └── Main.cpp
#+end_src


** CMakeLists.txt
#+begin_src text
  cmake_minimum_required (VERSION 3.5)

  project (<Project name>)

  set (CMAKE_CXX_FLAG "${CMAKE_CXX_FLAGS} -Wall -Werror -std=c++14")
  set (source_dir "${PROJECT_SOURCE_DIR}/src/")

  file (GLOB source_files "${source_dir}/*.cpp")

  add_executable (<Project name> ${source_files})
#+end_src

** build.sh

#+begin_src sh
  #!/bin/sh

  cmake -G "Codelite - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug
#+end_src

* How C++ Works

~<<~ is actually a function.

~std::cin.get()~ is just waiting for a enter to stop.

* How the C++ Compiler Works

compile and link.

generate object file for each of out cpp file.

file have no meaning in C++, you can compile a .god file, as long as you tell the compiler that it is cpp file.

pre-processing
- include: read and paste, JUST paste !!!
- define: replace keyword.
- if and endif:
  #+begin_src cpp
    #if 0
    here is no function
    #endif

    #if 1
    // here keep still
    #endif
  #+end_src  

* How the C++ Linker Works

find where each function is, and link them together.

you have to have an entry point, which is default called main.

after compiling, you function will convert to a function with signature. Linking is to link the function with same signature.

** function declaration in multiple file

#+begin_src cpp
  // case 1

  // log.h
  #pragma once
  void Log(char* message) {
    std::cout << message << std::endl;
  }

  // log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  // main.cpp
  #include <iostream>
  #include "log.h"

  int Multiply(int a, int b) {
    Log("Multiply");
    return a*b;
  }

  int main () {
    std::cout << Multiply(6,4) << std::endl;
    std::cin.get();
  }
#+end_src

This code will go wrong while linking, because ~#include~ is actually paste its code there, leading to appear 2 same function in cpp file and linker don't know which function to link.

*** solution 1 static keyword

#+begin_src cpp
  // log.h
  #pragma once

  static void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

use ~static~ so that every file have its own version of Log function. 

*** solution 2 only declare in header

#+begin_src cpp
  // log.h
  #pragma once

  void Log(char* message);

  // Log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

* Variables in C++

int has 4 bytes, which is 32 bits.
maximum is \( 2 ^{31}-1 \), one bit for sign.

bool take one bit to represent.

#+begin_src cpp
  #include <iostream>
  using namespace std;

  int main() {
    cout << sizeof(bool) << endl;
  }

#+end_src

#+RESULTS:
: 1

* Function in C++

prevent code duplication. 


* C++ Header Files

instead of paste declaration, you can use header file.

~#pragma once~: only include the file once in one transaction unit.

#+begin_src cpp
  #pragma once

  // equal to

  #ifndef _LOG_H
  #define _LOG_H

  // ...
  #endif
#+end_src

why this need?
#+begin_src cpp
  // common.h
  include "Log.h"

  // Log.h
  // ...

  // main.cpp
  #include "Log.h"
  #include "common.h"

#+end_src

it will go wrong.

** separate C and C++
#+begin_src cpp
  #include <stdlib.h> // C

  #include <iostream>
#+end_src

* How to DEBUG C++ in VISUAL STUDIO

skip

* CONDITIONS and BRANCHES in C++

optimization will avoid if, it make programme slow

separate the condition and the function body even only one statement, because while debugging, you cannot figure which statement the program run. 

actually separate every statements.

#+begin_src cpp
  else if 

  // equal to 
  else {
    if (){}
  }

#+end_src

* BEST Visual Studio Setup for C++ 
skip

* Loops in C++ 

while and for. 

for loop for specific time and make an index.

do while. 

* Control Flow in C++ 

- continue: go to the next iteration
- break: end the loop
- return: end the function
  
  
  
* POINTERS in C++

pointer is just memory address. 

** null pointer
#+begin_src cpp 
  void* ptr = NULL;
  void* ptr = nullptr;
  void* ptr = 0;
#+end_src

** assignment
#+begin_src cpp
  int var = 8;
  void* ptr = &var;
#+end_src

** type help computer to control var 
#+begin_src cpp
  int var = 8;
  int* ptr = &var;
  *ptr = 10;
#+end_src

** REFERENCES in C++

ampersand

#+begin_src cpp
  int a = 6;
  int& ref  = a; // assignment immediately
#+end_src

it is just an alias which will be replace after compiling.

This is just a syntax sugar. 
#+begin_src cpp 
  void increase(int *value) {
    ,*value ++;
  }

  int main(){
    int a  =5;
    increase(&a);
  }

  // equal to
  void increase(int& value) {
    value++;
  }

  int main() {
    int a = 5 ;
    increase(a);
    // just like increase (int& value = a);
  }
#+end_src

* CLASSES in C++
** concept
create your data structure. just like Structure in C.

#+begin_src cpp
  class Player {
    int x, y;
    int speed;
  }

  int main() {
    Player player;
  }
#+end_src

** public
it can only be accessed by its own function without public.
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
  };
#+end_src


** function
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
  player.Move(1,-1);



  void Move(Player& player, int xa, int ya) {
    player.x += xa * player.speed;
    player.y += ya * player.speed;
  }
  Move(player, 1, -1);

#+end_src

* CLASSES vs STRUCTS in C++

class is private by default.
struct is public.

This is the only difference.

#+begin_src cpp
  struct Player {
  private:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
#+end_src

* How to Write a C++ Class
#+begin_src cpp
  #include <iostream>

  class Log {
  public:
    const int LogLevelError = 0;
    const int LogLevelWarnning = 1;
    const int LogLevelInfo = 2;
    
  private:
    int m_LogLevel = LogLevelInfo;
    
  public:
    void SetLevel(int level){
      m_LogLevel = level;
    }
    void Error(const char* message){
      if (m_LogLevel >= LogLevelError){
        std::cout << "[Error]" << message << std::endl;
      }
    }
    
    void Warn(const char* message){
      if (m_LogLevel >= LogLevelWarnning) {
        std::cout << "[Warning]" << message << std::endl;
      }
    }
    void Info(const char* message){
      if (m_LogLevel >= LogLevelInfo ){
        std::cout << "[Info]" << message << std::endl;
      }
    }
  };

  int main() {
    Log log;
    log.SetLevel(log.LogLevelWarnning) ;
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    
    return 0;
  }
#+end_src

#+RESULTS:
| [Warning]Hello! |
| [Error]Hello!   |

* Static in C++

- outside of class: internal
- inside: share memory with others. 

today only talk about outside. 
  
#+begin_src cpp
  static int a = 5;
#+end_src

every var outside the function is considered as a global var. 
add static make it only visible in that one file.

use static as much as you can.

* Static for class and struct

make var only one, or shared across the class or struct.

let's learn from examples.

** example 1

#+begin_src cpp 
  #include <iostream>

  struct Entity {
    int x, y;
    
    void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int main() {
    Entity e;
    e.x = 2;
    e.y = 3;
    
    Entity ee= {4,6};

    e.Print();
    ee.Print();
    
    return 0;
  }
#+end_src

#+RESULTS:
| 2 | 3 |
| 4 | 6 |

** example 2
make the var static, across all entities, there is only one x, y, in other word, they shared x and y.

#+begin_src cpp 
  #include <iostream>

  struct Entity {
    static int x, y;
    
    void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int Entity::x;
  int Entity::y;
  // static in struct can not be touch outside
  // so when you declare one Entity, x and y inside did not be declared.

  int main() {
    Entity e;
    e.x = 2;
    e.y = 3;
    
    Entity ee;
    ee.x = 4;
    ee.y = 5;
    
    e.Print();
    ee.Print();
    
    return 0;
  }
#+end_src

#+RESULTS:
| 4 | 5 |
| 4 | 5 |

** example 3

This code went wrong, because static method can not access non static var.



#+begin_src cpp
  #include <iostream>

  struct Entity {
    int x, y;
    
    static void Print() {
      std::cout << x << " , " << y << std::endl;
    }
  };

  int Entity::x;
  int Entity::y;

  int main() {
    Entity::x = 2;
    Entity::y = 3;
    
    Entity::x = 4;
    Entity::y = 5;
    
    Entity::Print();
    Entity::Print();
    
    return 0;
  }
#+end_src

#+RESULTS:


That because method in class actually hidden the parameter.

#+begin_src cpp
  void Print(<Entity e>) {
    std::cout << <e.>x << " , " << <e.>y << std::endl;
  }
#+end_src

if you add the static, it is the same as you write the method outside the class, so the method use the var that are not exist. 

* ENUMS

** how to define
#+begin_src cpp
  #include <iostream>
  
  enum Example {
    A, B, C
    // default start from 0, step 1
  };
#+end_src

change attribute
#+begin_src cpp
  #include <iostream>

  enum Example : char{ // here it has to be integer
    A = 5, B, C
    // change the start. 
  };
#+end_src

** example in a class
how about inside a class.

#+begin_src cpp
  #include <stdio>

  class Log {
  public:
    enum Level {
      Error, Warning, Info
    }
    
    void Error(const char* message) {
      // ...
    }
    void SetLevel() {
      // ...
    }

  }
  int main() {
    Log log; // you just need to declare the class. 
    log.SetLevel(Log::Error); 
    // it will went wrong, because you have a Error enum and function.
  }
#+end_src

** best practice
#+begin_src cpp 
  enum Level {
    LevelError, LevelWarning, LevelInfo
  }
#+end_src


* Constructors

Constructor is a kind of initialize function.

when you use ~e.Print()~, it will request parameter already to be initialized rather than output a random value.

#+begin_src cpp
  class Log {
  public:
    int x;
    Log(){}; // it will set all value to be 0 default. 
  };
#+end_src

you can also initialize by a more convenient way.
#+begin_src cpp
  class Log {
  public:
    int x;
    Log (int X) {
      x = X;
    }
  }

  int main() {
    Log l(1);
  }
#+end_src

if you want only one class instance.

#+begin_src cpp
  class Log {
  private:
    Log() {}
  public:
    int x;
    static void Write() {
      //...
    }
  }

  int main() {
    Log l; // this is invalid.
  }
#+end_src


* Destructor

 
#+begin_src cpp
  #include <iostream>
  using namespace std;

  class Log {
  public:
    Log(){
      cout << "create class" << endl;
    };
    int x;
    ~Log(){
      cout << "destroy class" << endl;
    }
  };

  void Print() {
    Log l;
    l.~Log();
    cout << "print over" << endl;
  }
  
  int main() {
    Print();
    return 0;
  }
#+end_src

#+RESULTS:
| create  | class |
| destroy | class |
| print   | over  |
| destroy | class |

* Inheritance

it allow us to create child class, and avoid duplication. 

#+begin_src cpp 
  class Entity {
  public:
    int x, y;
    Entity () {};
    
    void Move(int xa, int ya) {
      x += xa;
      y += ya;
    } 
  };


  class Player : public Entity {
  public:
    char* name;
    
    void PrintName() {
      
    }
  }

  int main() {
    Player player;
    player.Move(1,1);
  }
#+end_src

* Virtual Function

This help to reduce duplication.

** fail to reduce
#+begin_src cpp
  #include <iostream>

  class Entity {
  public:
    std::string GetName() { return "Entity"; }
  };

  class Animal : public Entity {
  public:
    std::string sound;
    Animal (std::string sounda) {
      sound = sounda;
    }
    std::string GetName() { return sound; }
  };

  void MakeSound(Entity* entity) {
    std::cout << entity->GetName() << std::endl;
  }

  int main() {
    Entity* e = new Entity();
    MakeSound(e);
    
    Animal* a = new Animal("Dog");
    MakeSound(a);
 }
#+end_src

#+RESULTS:
| Entity |
| Entity |

but if we use virtual function, everything is different.

** best practice
#+begin_src cpp
  #include <iostream>

  class Entity {
  public:
    virtual std::string GetName() { return "Entity"; }
  };

  class Animal : public Entity {
  public:
    std::string sound;
    Animal (std::string sounda) {
      sound = sounda;
    }
    std::string GetName() override { return sound; }
  };

  void MakeSound(Entity* entity) {
    std::cout << entity->GetName() << std::endl;
  }

  int main() {
    Entity* e = new Entity();
    MakeSound(e);
     
    Animal* a = new Animal("Dog");
    MakeSound(a);
#+end_src

#+RESULTS:
| Entity |
| Dog    |

** conclusion

cpp in object-oriented language and class is the import way to realize that.
when you are writing a class, you must assume that there is an function every child-classes has, but every class is a slightly different. It is kind of like a var in class. 


* Interfaces (pure virtual functions)

It is a kind of virtual function. 

| feature   | virtual | pure |
|-----------+---------+------|
| implement | must    | no   |
| override  | y/n     | must |

#+begin_src cpp
  #include <iostream>

  class Printable 
  {
  public:
    virtual std::string GetClassName () = 0;
  };

  class Dog : public Printable
  {
  public:
    std::string GetClassName() override {
      return "Dog";
    }
  };

  void Print (Printable* obj)
  {
    std::cout << obj->GetClassName() << std::endl;
  }

  int main()
  {
    Dog* dog = new Dog();
    Print(dog);
  }
#+end_src

#+RESULTS:
: Dog

** conclusion

virtual function is the behavior that can be generalized.
pure virtual function is not. 

* Visibility

no effect on program performance, just help to organize the code.

- protected: in that scope, only sub-class object can access.
- private
- public
 
* Arrays

** define
#+begin_src cpp
  int example[5];
  exampe[i];

  // equal to 
  int* ptr = example;
  *(ptr+2);
    
#+end_src

index of array in bracket will always start at the beginning, and then do an addition.

** new keyword 

content in the heap just address, so it is bad for performance
#+begin_src cpp
  int example[5]; // this is created by stack

  int* another = new int[5];
  // this is created by heap
  // and will not destory untill you use
  delete[] another;
#+end_src

** size of array

#+begin_src cpp
  int count = sizeof(another) / sizeof(int) // just go wrong
#+end_src

** no var for assign in array
#+begin_src cpp
  int size = 5;
  int example[size];              // go wrong

  static const in exampleSize = 5;
  int example[exampleSize];       // work
#+end_src

** grammar sugar
raw arrays is faster.
standard array is safer.

use standard array can avoid maintain another size var.
counts just can got by size().
#+begin_src cpp
  std::array<int, 5> another;
  another.size();                 // work
#+end_src

* How Strings Work

** basic concept
string is an array of character. 

It ends with 00 in memory.

string and char pointer.

what the difference with
#+begin_src cpp
  #include <iostream>

  int main ()
  {
    char* name1 = "chero";
    char name2[6] = {'c', 'h', 'e', 'r', 'o', '\0'};

    char name3[5] = {'c', 'h', 'e', 'r', 'o'};
    char name4[6] = {'c', 'h', 'e', 'r', 'o', 0};
    
    std::cout << name1 <<std::endl;
    std::cout << name2 <<std::endl;
    std::cout << name3 <<std::endl; // remind the third line
    // it will continue until find the 0 or '\0'
    std::cout << name4 <<std::endl;
    
    return 0;
  }
#+end_src

#+RESULTS:
| chero      |
| chero      |
| cherochero |
| chero      |

** std::string

#+begin_src cpp
  std::string name = "chero";      // it is actually a char array. 

  // iostream have the string
  // but you have to use string to output it 
  #include <string>
  std::cout << naem << std::endl;
#+end_src


** connect string 
#+begin_src cpp
  std::strng name = "const" + "string";
  // this will go wrong 
  // because "const" is a const char 

  std::string name = "const";
  name += "string";
#+end_src

** string in function
in the function, the parameter is actually passing the value by copying. Due to the string copy is quite slow, you should avoid to passing the string.

use reference instead:
#+begin_src cpp
  void print(const std::string& str) 
  {
    std::cout << str << std::endl;
  }
#+end_src

* string literals
** basic
This is the string literals. 
#+begin_src cpp
  "cherno";
#+end_src

** you can't do
#+begin_src cpp
  char* name = "chero";
  // this is undefined behaviour.
  name[2]  = "2"; // you do not know what will happen

  // the correct way
  char name[] = "chero";
  const char* naem = "chero";
#+end_src


** namespace of string literal

#+begin_src cpp
  using namespace tsd::string_literals;
  std::string name0 = "cherno"s + " hello";
#+end_src

** defferent
#+begin_src cpp
  char name[] = "cherno";
  name[2] = 'a';
#+end_src
This going to work. why?
the compiler actually copy the first string into to another variable, then modify it.

* CONST

** * and &
what is * and & really mean in the cpp
Both * and & have two different context.

|            | *                    | &                  |
|------------+----------------------+--------------------|
| operator   | get value of address | get address of var |
| declarator | pointer var          | reference var      |
| value      | actually value       | variable name      |

#+begin_src cpp
  int *a = 4; // create a pointer var with type int 
  int &a = b; // create a reference var with type int
#+end_src

in other way, int is the data type, but * and & is the variable type.

they are more close to variable.
#+begin_src cpp
  int *a, b; // a with pointer int type, b with int type
  int *a, *b; // both pointer int type. 
#+end_src

but in other way, they are more close to type
#+begin_src cpp
  const int a  = 1;
  int *b = 2;

  b = &a;  // wrong
  b = (int*) &a;
#+end_src

the most important is that, know the * and & are operator and type declarator.

** go into const

use Uppercase name to indicate the const property. 

read left-to-right: const apply to the first one meet it.

#+begin_src cpp
  const int* a = new int;
  // const meet int: int value cannot be modify
  int const* a = new int;
  // the same as above

  int* const a = new int;
  // * meet const: point value cannot be modify

  const int* const a = new int;
  // apply the knowledge you learn.
#+end_src

** function const

the function promise:
- not to modify the value of member variable
- not to called non-const function, because other function are allowed to modify the member variable
#+begin_src cpp
  class Entity
  {
    private:
    int m_X, m_Y;
    public:
    int Get() const
    {
      return m_X;
    }
  }
#+end_src

** mutable
mutable variable change be change in the const function.
or const function can change the mutable variable. 
#+begin_src cpp
  class Entity
  {
  private:
    mutable int a = 0;
  public:
    void add() const 
    {
      a++;
      std::cout << a << std::endl;
    }
  }
#+end_src

* the mutable keyword

two way to use

- lambda
- const
  

** what is the lambda
It is a kind of function

#+begin_src cpp
  auto <function> = [<captured>] (<parameter>) {
    // ...
  }
#+end_src

you can use the variable outside the function directly.
*However*, you can not change the captured var in the function

come from
#+begin_src cpp
  void f (int a) {
    // ...
  }
#+end_src

you do not need to define the var and able to use it directly.
** mutable with lambda

it allow you to "change" the captured var in the lambda,
but actually you can not change the really value, it is a kind of copy behavior.
#+begin_src cpp
  int a = 5;
  auto f = [a] () mutable
  {
    a++;
  }
  f();
  std::cout << a << std::endl;    // still be 5
#+end_src


come from
#+begin_src cpp
  auto f = [a] () {
    int b = a;
    b++;
    // ...
  }
#+end_src

* Member initializer lists

it just a way to initialize the var in lists.

** do not change the sequence

Even if the sequence is no effect
#+begin_src cpp
  class Entity 
  {
    private:
    int a;
    int b;
    public:
    Entity ()
    : b(0), a(0) {
      // it will still be initialized in the declared sequence
    }
  }
#+end_src

But the wrong sequence may make you think it is reasonable to make a assignment depend on b. 
But it will be wrong, because a initialize first. 

** a functional difference

#+begin_src cpp
  class Entity
  {
    private: 
    std::string m_Name;
    int x,y,z;
    public:
    Entity() 
    : x(0), y(0), z(0)
    {
      m_Name = "Unknown";
    }
  }
#+end_src

Here the m_Name will initilize twice.

#+begin_src cpp
  #include <iostream>

  class Example
  {
    public:
    Example ()
    {
      std::cout << "Created Entity!" << std::endl;
    }
    
    Example(int x)
    {
      std::cout << "created Entity with " << x << std::endl;
    }
  };

  class Entity
  {
    private: 
    std::string m_Name;
    Example m_Example;
    public:
    Entity()
    {
      m_Name = "Unknown";
      m_Example = Example(8);
    }
  };

  int main() {
    Entity e0;
    
    return 0;
  }

#+end_src

#+RESULTS:
| Created | Entity! |      |   |
| created | Entity  | with | 8 |

** correct one
#+begin_src cpp
  #include <iostream>

  class Example
  {
    public:
    Example ()
    {
      std::cout << "Created Entity!" << std::endl;
    }
    
    Example(int x)
    {
      std::cout << "created Entity with " << x << std::endl;
    }
  };

  class Entity
  {
    private: 
    std::string m_Name;
    Example m_Example;
    public:
    Entity()
    : m_Example(Example(8))
    {
      m_Name = "Unknown";
    }
  };

  int main() {
    Entity e0;
    
    return 0;
  }

#+end_src

#+RESULTS:
: created Entity with 8


* Ternary Operators
syntax sugar for conditional assignment

#+begin_src cpp
  int a = b>5 ? 10 : 5;
#+end_src


* How to Create/Instantiate objects

stack and heap

new and delete

* The NEW Keyword

allocate memory in heap.

create int in heap
1. tell system need 4 bytes memory
2. find 4 bytes continuous

it it a bit slow.

#+begin_src cpp
  Entity* e = new Entity();

  // similar to
  Entity *e  = (Entity*) malloc(sizeof(Entity));
#+end_src

* Implicit Conversion and the Explicit Keyword

** Implicit Conversion

The code functions properly due to C++'s implicit conversion feature. When C++ identifies a compatible data type, it automatically performs the implicit conversion process.

#+begin_src cpp
  class Entity
  {
    private:
    std::string m_Name;
    int m_Age;
    public:
    Entity(const std::string& name)
    : m_Name(name), m_Age(-1) {}

    Entity(int age)
    : m_Name("Unknown"), m_Age(age) {}
  };

  int main() {
    Entity a = "Cherno";
    Entity b = 22;
  }
#+end_src

But it can only perform only on implicit conversion process per times.

#+begin_src cpp
  void PrintEntity(const Entity& entity) {
    //...
  }

  int main() {
    PrintEntity(22);
    PrintEntity("Cherno");        // go wrong
  }
#+end_src

For the first code, the number 22 needs direct conversion to an Entity object.

However, in the second code, "cherno" exists as a character array, requiring a two-step conversion process: char array -> string -> entity. 

** explicit
It prevents automatic implicit type conversions from occurring.

#+begin_src cpp
  class Entity
  {
    private:
    std::string m_Name;
    int m_Age;
    public:
    Entity(const std::string& name)
    : m_Name(name), m_Age(-1) {}

    explicit Entity(int age)
    : m_Name("Unknown"), m_Age(age) {}
  };

  int main() {
    Entity a = "Cherno";
    Entity b = 22;                // go wrong
    Entity b = (Entity) 22;
    Entity b(22);
  }
#+end_src

* Operators and operator Overloading

operator overloading allow you to customize the behavior of operator in cpp. 

** objects operate
Sometime you want to use the normal operator to manipulate new data structure, but the behavior is undefined.

#+begin_src cpp
  struct Vector2
  {
    float x, y;
    
    Vector2 (float x, float y)
    : x(x), y(y) {}
    
    Vector2 Add (const Vector2& other) const 
    {
      return Vector2(x+other.x, y+other.y);
    }
    
    Vector2 Multiply (const Vector2 other) const
    {
      return Vector2(x*other.y, y*other.y);
    }

  };

  int main() {
    Vector2 position(4.0f, 4.0f);
    Vector2 speed(1.0f, 1.0f);
    Vector2 powerup(1.1f, 1.1f);
    
    Vector2 result = position.Add(speed.Multiply(powerup));
  }
#+end_src

** operator overloading
These code work but too messy, we can do in a more tricky way in cpp--operator overloading.

#+begin_src cpp
  struct Vector2
  {
    float x, y;
    
    Vector2 (float x, float y)
    : x(x), y(y) {}


    Vector2 Add (const Vector2& other) const 
    {
      return Vector2(x+other.x, y+other.y);
    }
    Vector2 operator+ (const Vector2& other) const
    {
      return Add(other);
    }  
    
    Vector2 Multiply (const Vector2& other) const
    {
      return Vector2(x*other.y, y*other.y);
    }
    Vector2 operator* (const Vector2& other) const
    {
      return Mutiply(other);
    }

  };

  int main() {
    Vector2 position(4.0f, 4.0f);
    Vector2 speed(1.0f, 1.0f);
    Vector2 powerup(1.1f, 1.1f);
    
    // Vector2 result = position.Add(speed.Multiply(powerup)); 
    Vector2 result = position + speed * powerup;
  }
#+end_src

** practice: overloading  <<
#+begin_src cpp
  struct Entity
  {
    float x, y;

    Entity (float x, float y)
    : x(x), y(y) {}
  };

  std::ostream& operator<< (std::ostream& stream, const Entity& other) const
  {
    stream << other.x << " , " << other.y;
    return stream;
  }

  int main()
  {
    Entity e(1.0f, 1.0f);

    cout << e << endl;
  }
#+end_src

** practice overloading ==
#+begin_src cpp
  struct Vector2
  {
    float x, y;

    Vector2 (float x, float y)
    : x(x), y(y) {}

    Vector2 operator== (const Vector2& other) const
    {
      return x==other.x && y==other.y;
    }

  };
#+end_src

* The "this" keyword

this is a pointer that refers to the current object instance within a member function.

#+begin_src cpp
  class Entity
  {
  public:
    int x, y;
    Entity(int x, int y)
    {
      // x=x; the variable in this function is priorty
      this->x = y;
      this->y = y;
    }
  }
#+end_src

* Object Lifetime

stack based variable live in the scope.
heap based variable live until be deleted.

** wrong example
This example is entirely incorrect.
The data that the pointer references will be destroyed beyond the scope.

#+begin_src cpp
  int* CreateArray()
  {
    int* array[50];
    return array;
  }

  // what you should do
  int* ModifyArray(int* array) 
  {
    // do something
    return array;
  }
#+end_src

** auto delete the heap

#+begin_src cpp
  class Entity
  {
    
  };

  class ScopedPtr
  {
  private:
    Entity* m_ptr;
  public:
    ScopedPtr(Entity* ptr)
    : m_ptr(ptr) {}
    
    ~ScopedPtr()
    {
      delete m_ptr;
    }
  }

  int main()
  {
    {
      ScopedPtr e = new Entity();
      // Entity* e = new Entity();  this will not be deleted beyond the scope.
    }
  }
#+end_src

* smart pointers

smart pointer can help you never write the new and delete in your code.

~#include <memory>~

It is essentially an encapsulated raw pointer, and when you invoke the smart pointer, it will execute the new operation, and depending on which smart pointer you utilized there will be certain memory that gets released.

** unique pointer
it is a scoped pointer.

You cannot copy the pointer, because maintaining multiple pointers pointing to the same memory address will result in the memory being freed when any one pointer gets destroyed.

#+begin_src cpp
  int main()
  {
    {
      std::unique_ptr<Entity> entity = std::make_unique<Entity>();

      entity->Print();
    }
  }

#+end_src

** shared pointer

every time you call the shared pointer, it will increase the reference count in it.

#+begin_src cpp
  {
    std::shared_prt<Entity> e0;
    {
      std::shared_ptr<Entity> sharedEntity = std::make_hared<Entity>();  
      e0 = sharedEntity;
    }
  }
#+end_src

here, the sharedEntity will not be destroy beyond its scope, it shared the scope with all shared pointer.

** weak pointer

- Holds a non-owning reference to an object managed by =shared_ptr=
- Doesn't affect the reference count
- Can check if the object still exists before accessing it
  
#+begin_src cpp
  {
    std::weak_ptr<Entity> e0;
    {
      std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();
      e0 = sharedEntity;
    }
  }
#+end_src

here the sharedEntity will be destroy beyond its scope, because the weak pointer will not control the memory. 

** copying and copy constructor

** avoid copying
because it is bad for performance.
remember always pass your object by references.

** copy constructor

it is the behavior that assign operator do copy.

It is better to define the copy constructor by yourself,
because the default copy constructor is do it byte-by-byte.

what is the "byte-by-byte" mean? look at the example below.

*** problem of default copy constructor
#+begin_src cpp
  class String
  {
  private:
    char* m_Buffer;
    unsigned int m_Size;
  public:
    String(const char* string)
    {
      m_Size = strlen(string);
      m_Buffer = new char[m_Size+1];
      memcpy(m_Buffer, string, m_Size);
      m_Buffer[m_Size] = 0;
    }
    
    friend std::ostream& operator<< (std::ostream& stream, const String& string);
  }

  std::ostream& operator<< (std::ostream& stream, const String& string)
  {
    stream << string.m_Buffer;
    return stream;
  }

  int main()
  {
    String string = "Cherno";
    String second = string;
  }
#+end_src

look ~String second = string;~ at the main function.

whether it creates a new memory to copy the string or just pointer to the same memory address?

it is pointing to the same memory address.

**** why

#+begin_src cpp
  class String
  {
  private:
    char* m_Buffer;
    unsigned int m_Size;
  public:
    String(const char* string)
    {
      m_Size = strlen(string);
      m_Buffer = new char[m_Size+1];
      memcpy(m_Buffer, string, m_Size);
      m_Buffer[m_Size] = 0;
    }
  }
#+end_src


In this class, it only define the behavior when passing the *char array* as parameter, rather than string.

So it will follow the default copy constructor, which is byte-by-byte:

1. copy the char array, which is address.(That's the problem)
2. copy the integer properly.

   
**** build your own copy constructor

#+begin_src cpp
  class String
  {
  private:
    char* m_Buffer;
    unsigned int m_Size;
  public:
    // ...
    String (const String& other)
    : m_Size(other.m_Size)
    {
      memcpy(m_Buffer, string, m_size+1);
    }
  }

  int main()
  {
    String string = "Cherno";
    String second = string;
  }
#+end_src


Now every run properly.

** The Arrow Operator

*** main
#+begin_src cpp
  class Entity
  {
    public:
    void Print() const
    {
      std::cout << "Hello!" << std::endl;
    }
  };

  int main()
  {
    Entity e;
    e.Print();

    Entiry* ptr = &e;
    ptr.Print();  // go wrong
    ,*ptr.Pritn(); // this also go wrong
    (*ptr).Print();

    ptr->Print(); // arrow opertor, a shorcut

    std::cin.get();
#+end_src


*** overload

#+begin_src cpp
  class Entity
  {
    public:
    void Print() const
    {
      std::cout << "Hello!" << std::endl;
    }
  };

  class ScopedPtr
  {
  private:
    Entity* m_Obj;
  public:
    ScopedPtr(Entity* entity)
      : m_Obj(entity) {}
    ~ScopedPtr()
    {
      delete m_Obj;
    }
  };
  
  int main()
  {
    ScopedPtr entity = new Entity();
    entity->Print(); // Now it can not call the Print funciton
    std::cin.get();
  }
#+end_src


as result, we need to do an overload

#+begin_src cpp
  class ScopedPtr
  {
  private:
    Entity* m_Obj;
  public:
    ScopedPtr(Entity* entity)
      : m_Obj(entity) {}
    ~ScopedPtr()
    {
      delete m_Obj;
    }
    Entity* operator->()
    {
      return m_Obj;
    }
  };
#+end_src

*** an other example
#+begin_src cpp
  struct Vector3
  {
    float x, y, z;
  };

  int main()
  {
    int offset = (int)&((Vector3*)nullptr)->z;
    std::cout << offset << std::endl;
    
    std::cin.get();
  }
#+end_src

in the offset, what the expression mean??? I don't understand

Looking at your C++ notes, you have a very comprehensive overview! Let me address your question at the end about this confusing expression:

#+begin_src cpp
int offset = (int)&((Vector3*)nullptr)->z;
#+end_src

* Dynamic Arrays

vector is in stl. It is actually a dynamic array, rather than mathematical vector.

#+begin_src cpp 
  struct Vertex
  {
    float x, y, z;
  };

  std::ostream& operator<< (std::ostream& stream, const Vertex& vertex)
  {
    stream << vertex.x << ", " << vertex.y << ", " << vertex.z;
    return stream;
  }

  int main()
  {
    std::vector<Vertex*> vertices;
    vertices.push_back({1, 2, 3});
    vertices.push_back({4, 5, 6});
    
    for (int i=0; i<vertices.size(); i++)
    {
      std::cout << vertics[i] << std::endl;
    }
    
    for (Vertex& v: vertices)
    {
      std::cout << v << std::endl;
    }
    
    vertices.clear();
    vertices.erase(vertices.begin() + 1);  // have to use begin and addition.
  }
#+end_src

** simpler way to write loop
similar  to python. 
#+begin_src cpp
  for (Vertex& v: vertices)
  {
    std::cout << v << std::endl;
  }
#+end_src

** add

#+begin_src cpp
  std::vector<Vertex*> vertices;

  vertices.push_back({1, 2, 3});
#+end_src

** clean

#+begin_src cpp
  vertices.clear(); // clean all

  vertices.erase(vertices.begin() + 1); // remove the certain one
  // it have to use the begin function. 
#+end_src

* Optimizing the usage fo std::vector

how to std::vector push_back work, it will reallocate new block of the memory to at least contain the new all data, then delete the old location.

** waste performance
#+begin_src cpp
  #include <iostream>
  #include <vector>
  #include <string>

  struct Vertex
  {
    float x, y, z;

    Vertex(float x, float y, float z)
        : x(x), y(y), z(z) {}
    
    Vertex(const Vertex& vertex)
    : x (vertex.x), y (vertex.y), z (vertex.z)
    {
      std::cout << "copied" << std::endl;
    }
  };

  int main()
  {
    std::vector<Vertex> vertices;
    vertices.push_back( { 1, 2, 3 });
    std::cout << std::endl;
    
    vertices.push_back( { 1, 2, 3 });
    std::cout << std::endl;
    
    vertices.push_back( { 1, 2, 3 });
  }
#+end_src

#+RESULTS:
| copied |
|        |
| copied |
| copied |
|        |
| copied |
| copied |
| copied |

** optimization
There are some thing we can optimize.
1. the first time, it allocate the memory in the heap of main function, then copy into the Vertex object.
2. the second time, it resize twice. why not tell it the number we want to push.


*** allocate enough space at a time.
#+begin_src cpp
  #include <iostream>
  #include <vector>
  #include <string>

  struct Vertex
  {
    float x, y, z;

    Vertex(float x, float y, float z)
        : x(x), y(y), z(z) {}
    
    Vertex(const Vertex& vertex)
    : x (vertex.x), y (vertex.y), z (vertex.z)
    {
      std::cout << "copied" << std::endl;
    }
  };

  int main()
  {
    std::vector<Vertex> vertices;
    vertices.reserve(3);
    vertices.push_back( { 1, 2, 3 });
    std::cout << std::endl;
    
    vertices.push_back( { 1, 2, 3 });
    std::cout << std::endl;
    
    vertices.push_back( { 1, 2, 3 });
  }
#+end_src

#+RESULTS:
| copied |
|        |
| copied |
|        |
| copied |

*** avoid additional copying. 
#+begin_src cpp
  #include <iostream>
  #include <vector>
  #include <string>

  struct Vertex
  {
    float x, y, z;

    Vertex(float x, float y, float z)
        : x(x), y(y), z(z) {}
    
    Vertex(const Vertex& vertex)
    : x (vertex.x), y (vertex.y), z (vertex.z)
    {
      std::cout << "copied" << std::endl;
    }
  };

  int main()
  {
    std::vector<Vertex> vertices;
    vertices.reserve(3);
    vertices.emplace_back(  1, 2, 3 );
    std::cout << std::endl;
    
    vertices.emplace_back(  1, 2, 3 );
    std::cout << std::endl;
    
    vertices.emplace_back(  1, 2, 3 );
  }
#+end_src

#+RESULTS:
|   |
|   |

Now there is no copy.

* Local Static

it makes the local variable to keep live in the in entire program, but can only be access by the local function.

** without static
#+begin_src cpp
  #include <iostream>

  void Function()
  {
    int i = 0;
    i++;
    std::cout << i << std::endl;
  }

  int main()
  {
    Function();
    Function();
  }



#+end_src

#+RESULTS:
| 1 |
| 1 |

** within static 
#+begin_src cpp
  #include <iostream>

  void Function()
  {
    static int i = 0;
    i++;
    std::cout << i << std::endl;
  }

  int main()
  {
    Function();
    Function();

    // i++; is unavailable outside the function.
  }

#+end_src

#+RESULTS:
| 1 |
| 2 |

** static outside
#+begin_src cpp
  #include <iostream>

  static int i = 0;

  void Function()
  {

    i++;
    std::cout << i << std::endl;
  }

  int main()
  {
    Function();
    i++;
    Function();
  }
#+end_src

#+RESULTS:
| 1 |
| 3 |

** static in class
#+begin_src cpp 
  class Singleton
  {
  public:
    static Singleton& Get()
    {
      static Singleton instance;
      return instance;
    }
    
    void Hell() {}
  };

  int main() 
  {
    Singleton::Get().Hello();
  }
#+end_src

* Using Libraries

linking binary.

- include
- library

- static linking: linking everything.
- dynamic linking: linking when needing.

Not that important.

~.h~ only declares function. 
~.lib~ contains the definition of fuction. 

* Using Dynamic Libraries

ommited


* TODO Making and Working with Libraries(Multiple Projects in Visual Studio)

How to do that in Linux. 

* How to Deal with Multiple Return Values


** pass multiple parameter

#+begin_src cpp
  void multiple(.., std::string& ptr1, std::string& ptr2)
  {
    // ...
    ptr1 = "good";
    ptr2 = "goodway";
  }
#+end_src

** use vector and array

#+begin_src cpp 
  #include <vector>

  static std::vector<std::string> multiple()
  {
    std::vector<std::string> results;
    
    results[0] = vs;
    results[1] = fs;
    return results;
  }


  // the other way

  #include <array>

  static std::array<std::string, 2> multiple()
  {
    std::array<std::string, 2> results;
    
    results[0] = vs;
    results[1] = fs;
    
    return reesults;
  }
#+end_src

** use tuple and pair
this allow to return different value, different way use different way to select the value. 
#+begin_src cpp
  #include <functional>
  static std::tuple<std::string, int> multiple ()
  {
    // ...
    return stdd::make_pair(vs, fs);
  }
  std::get<0>

  // pair

  static std::pair<std::string, int> multiple ()
  {
    // ...
    return std::make_pair(vs, fs);
  }
  vector.first;
#+end_src

** create a struct

create a struct is the best way. 
#+begin_src cpp
  struct Test
  {
    std::string first;
    std::string second;
  };

  static Test Multiple()
  {
    return {first, second};
  }

  unsigned in tshader = CreateShader(source.first, source.second);

#+end_src

* Templates

similar to generics

macro

compiler write code for you.

#+begin_src  cpp
  void Print(int value)
  {
    std::cout<< value <<std:endl;
  }

  void Print(std::string value)
  {
    std::cout << value << std::endl;
  }
#+end_src

Those code are the same except the type.

#+begin_src cpp
  template <typename T>
  void Print(T value) {
    std::cout << value << std::endl;
  }

  int main()
  {
    Print(5);
    Print("Hello");
  }

#+end_src

it will only compile when it is called.

#+begin_src cpp
  template<typename T>
  void Print(T value)
  {
    std::cout << value << std::endl;
  }

  int main()
  {
    Print<int>(5);
    Print(5);
  }
#+end_src

#+begin_src  cpp
  template<int N>

  class Array
  {
  private:
    int m_Array[N];
  public:
    int GetSize() const { return 5; }
  };

  int main()
  {
    Array<5> array;
  }
#+end_src

This first element in the <> will replace the template.

#+begin_src cpp
  template<typename T, int N>

  class Array
  {
  private:
    T m_Array[N];
  public:
    // ...
  }

  Array<int, 5> array;

#+end_src

* Stack and Heap Memory

stack is a area with predefined memory around 1-8 MB.

stack just stacks everything, it just move the pointer to find the data, so it is very fast.
- last in, first out.

And heap is also a kind of stacks, but it only save the pointers, the actual data to distributed. As a result, it i much more slower and will meet much more cache miss.

* Macros

it is a board term. 

use preprocesor macro file operation.

it just replace some text in our code.

** example
#+begin_src  cpp
  #define WAIT std::cin.get()

  int main()
  {
    WAIT;
  }

#+end_src

do not write the macro like that.

** better
#+begin_src cpp
  #define LOG(x) std::cout << x << std::endl

  LOG("hello");
#+end_src

the better
#+begin_src cpp
  #ifdef PR_DEBUG
  #define LOG(x) std::cout << x << std::endl
  #else
  #define LOG(x)
  #endif
#+end_src

other way
#+begin_src cpp
  #define PR_DEBUG 0
  
  #ifdef PR_DEBUG == 1
  #define LOG(x) std::cout << x << std::endl
  #elif defined(PR_RELEASE)
  #define LOG(x)
  #endif
#+end_src

** special
#+begin_src cpp
  #define MAIN int main()\
  {\
    std::...;\
  }

  MAIN

#+end_src


* The auto keyword

#+begin_src cpp 
  int main()
  {
    int a = 5;
    auto b = a;
    std::cin.get();
  }
#+end_src

it is good if you change your API, then you do not need change your code.

How ever it may break your cod.
#+begin_src cpp
  char* GetName()
  {
    return "Cherno";
  }

  int main()
  {
    auto name = GetName();

    int a = name.size(); // this will break your code.
    // char* did not have size method.
  }

#+end_src

#+begin_src cpp
  using Dev = std.............;
  const Dev device = ...;

  // or
  const auto device = .....;
#+end_src

* Static Arrays

** Definition
#+begin_src cpp
  #include <array>

  int main()
  {
    int dataOld[5];
    dataOld[0] = 0;

    // equal to 
    std::array<int, 5> data;
    data[0]=2;
  }

#+end_src

** advantages
1. maximum optimized
2. max speed
3. not store the size, it is the template variable.

* Function Pointers

** Definition
#+begin_src cpp 
  void HelloWorld()
  {
    std::cout << "hello, world!" << std::endl;
  }

  int main()
  {
    // void(*function)();
    auto function = HelloWorld;

    void(*cherno) () = Helloworld;
    cherno();

    void(*cherno)();
    cherno = function;

    typedef void(*cherno)();
    cherno function = HelloWorld;

    function();
    function();
  }

#+end_src

** real example

#+begin_src cpp
  void PrintValue(int value)
  {
    std::cout << value << std::endl;
  }

  void ForEach(const std::vector<int>& values, void(*func)(int))
  {
    for (int value : values)
    {
      func(value);
    }
  }

  int main()
  {
    std::vector<int> values = {1, 2, 3, 4};
    ForEach(values, PrintValue);
  }
#+end_src

* Lambdas

it is a function when no necessary to define function.

** how to use
#+begin_src cpp
  #include <funcitonal>
  void  ForEach(const std::vector<int>& values, const std::function<void(int)>& func)
  {
    // ...
  }
  int main()
  {
    int a = 5;
    auto lambda = [&a](int value) { std::cout << a << std::endl; };

    ForEach(values, lambda);
  }

#+end_src

** example

#+begin_src cpp
  int main()
  {
    std::vector<int> values = {1,2,3};
    auto it = std::find_if(values.begin(), values.end(), [](int value) {return value > 3;});

    std::cout << *it << std::endl;
    
  }

#+end_src

* Why I don't "using namespace std"

many company will define their own std.

It confusing to use the code. 

* Namespaces

separate you own function easily.

#+begin_src cpp
  namespace apple
  {
    void Print()
    {
      //....
    }
    namespace function{
      void Print(){}
    }
  }

  namespace orange
  {
    void Print()
    {
      // ...
    }
  }

  int main()
  {
    apple::Print();
    apple::function::Print();
  }

#+end_src

use single function in namespace.

#+begin_src cpp
  using apple::print;
  namespace a = apple;
#+end_src

* Threads

** single thread
#+begin_src cpp
  #include <thread>

  void DoWork()
  {
    while (true)
      {
        
      }
    // ...
  }

  int main()
  {
    std::thread worker(DoWork);

    worker.join();
    // after these code,
    // nothing will run before worker done.
  }
#+end_src

** multiple thread
#+begin_src cpp
  #include <thread>

  static bool s_Finished = false;
  void DoWork()
  {
    using namespace std::literals::chrono_literals;

    std::cout << "started thread id= " << std::this_thread::get_id() << std::endl;
    
    while (s_Finished)
      {
        std::cout << "hello" << std::endl;
        std::this_thread::sleep_for(1s);
      }
  }

  int main()
  {
    std::thread worker(DoWork);

    std::cin.get();
    s_Finished = true;

    worker.join();
    std::cout << "done" << std::endl;
    std::cout << "started thread id= " << std::this_thread::get_id() << std::endl;
    
    std::cin.get()    
  }

#+end_src
