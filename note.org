#+title: Notes

* How to Setup C++ on Linux

** system setup
#+begin_src sh
  sudo apt update && sudo apt upgrade
  sudo apt install cmake g++
#+end_src


** project tree

#+begin_src plain
 ./
 ├── build.sh
 ├── CMakeLists.txt  
 ├── README.org
 └── src
     └── Main.cpp
#+end_src


** CMakeLists.txt
#+begin_src text
  cmake_minimum_required (VERSION 3.5)

  project (<Project name>)

  set (CMAKE_CXX_FLAG "${CMAKE_CXX_FLAGS} -Wall -Werror -std=c++14")
  set (source_dir "${PROJECT_SOURCE_DIR}/src/")

  file (GLOB source_files "${source_dir}/*.cpp")

  add_executable (<Project name> ${source_files})
#+end_src

** build.sh

#+begin_src sh
  #!/bin/sh

  cmake -G "Codelite - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug
#+end_src

* How C++ Works

~<<~ is actually a function.

~std::cin.get()~ is just waiting for a enter to stop.

* How the C++ Compiler Works

compile and link.

generate object file for each of out cpp file.

file have no meaning in C++, you can compile a .god file, as long as you tell the compiler that it is cpp file.

pre-processing
- include: read and paste, JUST paste !!!
- define: replace keyword.
- if and endif:
  #+begin_src cpp
    #if 0
    here is no function
    #endif

    #if 1
    // here keep still
    #endif
  #+end_src  

* How the C++ Linker Works

find where each function is, and link them together.

you have to have an entry point, which is default called main.

after compiling, you function will convert to a function with signature. Linking is to link the function with same signature.

** function declaration in multiple file

#+begin_src cpp
  // case 1

  // log.h
  #pragma once
  void Log(char* message) {
    std::cout << message << std::endl;
  }

  // log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  // main.cpp
  #include <iostream>
  #include "log.h"

  int Multiply(int a, int b) {
    Log("Multiply");
    return a*b;
  }

  int main () {
    std::cout << Multiply(6,4) << std::endl;
    std::cin.get();
  }
#+end_src

This code will go wrong while linking, because ~#include~ is actually paste its code there, leading to appear 2 same function in cpp file and linker don't know which function to link.

*** solution 1 static keyword

#+begin_src cpp
  // log.h
  #pragma once

  static void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

use ~static~ so that every file have its own version of Log function. 

*** solution 2 only declare in header

#+begin_src cpp
  // log.h
  #pragma once

  void Log(char* message);

  // Log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

* Variables in C++

int has 4 bytes, which is 32 bits.
maximum is \( 2 ^{31}-1 \), one bit for sign.

bool take one bit to represent.

#+begin_src cpp
  #include <iostream>
  using namespace std;

  int main() {
    cout << sizeof(bool) << endl;
  }

#+end_src

#+RESULTS:
: 1

* Function in C++

prevent code duplication. 


* C++ Header Files

instead of paste declaration, you can use header file.

~#pragma once~: only include the file once in one transaction unit.

#+begin_src cpp
  #pragma once

  // equal to

  #ifndef _LOG_H
  #define _LOG_H

  // ...
  #endif
#+end_src

why this need?
#+begin_src cpp
  // common.h
  include "Log.h"

  // Log.h
  // ...

  // main.cpp
  #include "Log.h"
  #include "common.h"

#+end_src

it will go wrong.

** separate C and C++
#+begin_src cpp
  #include <stdlib.h> // C

  #include <iostream>
#+end_src

* How to DEBUG C++ in VISUAL STUDIO

skip

* CONDITIONS and BRANCHES in C++

optimization will avoid if, it make programme slow

separate the condition and the function body even only one statement, because while debugging, you cannot figure which statement the program run. 

actually separate every statements.

#+begin_src cpp
  else if 

  // equal to 
  else {
    if (){}
  }

#+end_src
