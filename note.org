#+title: Notes

* How to Setup C++ on Linux

** system setup
#+begin_src sh
  sudo apt update && sudo apt upgrade
  sudo apt install cmake g++
#+end_src


** project tree

#+begin_src plain
 ./
 ├── build.sh
 ├── CMakeLists.txt  
 ├── README.org
 └── src
     └── Main.cpp
#+end_src


** CMakeLists.txt
#+begin_src text
  cmake_minimum_required (VERSION 3.5)

  project (<Project name>)

  set (CMAKE_CXX_FLAG "${CMAKE_CXX_FLAGS} -Wall -Werror -std=c++14")
  set (source_dir "${PROJECT_SOURCE_DIR}/src/")

  file (GLOB source_files "${source_dir}/*.cpp")

  add_executable (<Project name> ${source_files})
#+end_src

** build.sh

#+begin_src sh
  #!/bin/sh

  cmake -G "Codelite - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug
#+end_src

* How C++ Works

~<<~ is actually a function.

~std::cin.get()~ is just waiting for a enter to stop.

* How the C++ Compiler Works

compile and link.

generate object file for each of out cpp file.

file have no meaning in C++, you can compile a .god file, as long as you tell the compiler that it is cpp file.

pre-processing
- include: read and paste, JUST paste !!!
- define: replace keyword.
- if and endif:
  #+begin_src cpp
    #if 0
    here is no function
    #endif

    #if 1
    // here keep still
    #endif
  #+end_src  

* How the C++ Linker Works

find where each function is, and link them together.

you have to have an entry point, which is default called main.

after compiling, you function will convert to a function with signature. Linking is to link the function with same signature.

** function declaration in multiple file

#+begin_src cpp
  // case 1

  // log.h
  #pragma once
  void Log(char* message) {
    std::cout << message << std::endl;
  }

  // log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  // main.cpp
  #include <iostream>
  #include "log.h"

  int Multiply(int a, int b) {
    Log("Multiply");
    return a*b;
  }

  int main () {
    std::cout << Multiply(6,4) << std::endl;
    std::cin.get();
  }
#+end_src

This code will go wrong while linking, because ~#include~ is actually paste its code there, leading to appear 2 same function in cpp file and linker don't know which function to link.

*** solution 1 static keyword

#+begin_src cpp
  // log.h
  #pragma once

  static void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

use ~static~ so that every file have its own version of Log function. 

*** solution 2 only declare in header

#+begin_src cpp
  // log.h
  #pragma once

  void Log(char* message);

  // Log.cpp
  #include <iostream>
  #include "log.h"

  void InitLog() {
    Log("initial message");
  }

  void Log(char* message) {
    std::cout << message << std::endl;
  }
#+end_src

* Variables in C++

int has 4 bytes, which is 32 bits.
maximum is \( 2 ^{31}-1 \), one bit for sign.

bool take one bit to represent.

#+begin_src cpp
  #include <iostream>
  using namespace std;

  int main() {
    cout << sizeof(bool) << endl;
  }

#+end_src

#+RESULTS:
: 1

* Function in C++

prevent code duplication. 


* C++ Header Files

instead of paste declaration, you can use header file.

~#pragma once~: only include the file once in one transaction unit.

#+begin_src cpp
  #pragma once

  // equal to

  #ifndef _LOG_H
  #define _LOG_H

  // ...
  #endif
#+end_src

why this need?
#+begin_src cpp
  // common.h
  include "Log.h"

  // Log.h
  // ...

  // main.cpp
  #include "Log.h"
  #include "common.h"

#+end_src

it will go wrong.

** separate C and C++
#+begin_src cpp
  #include <stdlib.h> // C

  #include <iostream>
#+end_src

* How to DEBUG C++ in VISUAL STUDIO

skip

* CONDITIONS and BRANCHES in C++

optimization will avoid if, it make programme slow

separate the condition and the function body even only one statement, because while debugging, you cannot figure which statement the program run. 

actually separate every statements.

#+begin_src cpp
  else if 

  // equal to 
  else {
    if (){}
  }

#+end_src

* BEST Visual Studio Setup for C++ 
skip

* Loops in C++ 

while and for. 

for loop for specific time and make an index.

do while. 

* Control Flow in C++ 

- continue: go to the next iteration
- break: end the loop
- return: end the function
  
  
  
* POINTERS in C++

pointer is just memory address. 

** null pointer
#+begin_src cpp 
  void* ptr = NULL;
  void* ptr = nullptr;
  void* ptr = 0;
#+end_src

** assignment
#+begin_src cpp
  int var = 8;
  void* ptr = &var;
#+end_src

** type help computer to control var 
#+begin_src cpp
  int var = 8;
  int* ptr = &var;
  *ptr = 10;
#+end_src

** REFERENCES in C++

ampersand

#+begin_src cpp
  int a = 6;
  int& ref  = a; // assignment immediately
#+end_src

it is just an alias which will be replace after compiling.

This is just a syntax sugar. 
#+begin_src cpp 
  void increase(int *value) {
    ,*value ++;
  }

  int main(){
    int a  =5;
    increase(&a);
  }

  // equal to
  void increase(int& value) {
    value++;
  }

  int main() {
    int a = 5 ;
    increase(a);
    // just like increase (int& value = a);
  }
#+end_src

* CLASSES in C++
** concept
create your data structure. just like Structure in C.

#+begin_src cpp
  class Player {
    int x, y;
    int speed;
  }

  int main() {
    Player player;
  }
#+end_src

** public
it can only be accessed by its own function without public.
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
  };
#+end_src


** function
#+begin_src cpp
  class Player {
  public:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
  player.Move(1,-1);



  void Move(Player& player, int xa, int ya) {
    player.x += xa * player.speed;
    player.y += ya * player.speed;
  }
  Move(player, 1, -1);

#+end_src

* CLASSES vs STRUCTS in C++

class is private by default.
struct is public.

This is the only difference.

#+begin_src cpp
  struct Player {
  private:
    int x, y;
    int speed;
    
    // you can contain function in class.
    void Move(int xa, int ya) {
      x+= xa*speed;
      y+= ya*speed;
    }
  };
#+end_src

* How to Write a C++ Class
#+begin_src cpp
  #include <iostream>

  class Log {
  public:
    const int LogLevelError = 0;
    const int LogLevelWarnning = 1;
    const int LogLevelInfo = 2;
  private:
    int m_LogLevel = LogLevelInfo;
    
  public:
    void SetLevel(int level){
      m_LogLevel = level;
    }
    void Error(const char* message){
      if (m_LogLevel >= LogLevelError){
        std::cout << "[Error]" << message << std::endl;
      }
    }
    
    void Warn(const char* message){
      if (m_LogLevel >= LogLevelWarnning) {
        std::cout << "[Warning]" << message << std::endl;
      }
    }
    void Info(const char* message){
      if (m_LogLevel >= LogLevelInfo ){
        std::cout << "[Info]" << message << std::endl;
      }
    }
  };

  int main() {
    Log log;
    log.SetLevel(log.LogLevelWarnning) ;
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    
    return 0;
  }
#+end_src

#+RESULTS:
| [Warning]Hello! |
| [Error]Hello!   |

